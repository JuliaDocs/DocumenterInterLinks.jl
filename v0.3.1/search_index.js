var documenterSearchIndex = {"docs":
[{"location":"syntax/#Syntax","page":"Syntax","title":"Syntax","text":"","category":"section"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"The possible forms of an @extref link are as follows:","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"[title](@extref) where title is a section title\n[`name`](@extref) where name is a fully specified code object 🏅\n[text](@extref name) where text is an arbitrary link text and name (optionally enclosed in backticks) is a fully specified code object or sluggified section title. 🏅\n[title](@extref project) where project is a known project in the underlying InterLinks object\n[`name`](@extref project) 🥈\n[text](@extref :role:`name`)\n[text](@extref :domain:role:`name`)\n[text](@extref project name) 🏅\n[text](@extref project :role:`name`) 🥈\n[text](@extref project :domain:role:`name`)","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"The most commonly used forms of syntax should be (2), (3), and (8) 🏅, with (5), and (9) being useful in some situations 🥈, see the Recommended Syntax.","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"Assuming an InterLinks instance links, all of the above will reference the DocInventories.InventoryItem links[project][\":domain:role:name\"]. If project is not specified, the first project in links that contains a matching item will be used (up to a performance shortcut). If domain or role are not given, any domain or role will match.","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"Forms (1-3) most directly extend Documenter's built-in @ref syntax. Forms (4) and (5) take precedence over form (3) if project is a known element of links. The use of backticks around name in form (3) would avoid this ambiguity.","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"Forms (1) and (4) apply a sluggification to transform title into a name.  This matches Documenter's @ref behavior for linking to section titles. The specifics of the sluggification algorithm are not guaranteed to be stable between different versions of Documenter, and they do not match the sluggification used by other documentation generators like Sphinx. For this reason, forms (1) and (4) only have limited usefulness.","category":"page"},{"location":"syntax/#Performance-Tips","page":"Syntax","title":"Performance Tips","text":"","category":"section"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"Although resolving external references is unlikely to have a significant impact on the build time of a project's documentation, there are some internals that affect the relative performance of the above @extref syntax forms.","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"When no project is given in the @extref specification, all projects declared in the InterLinks object may have to be searched for a matching item. The projects are searched in order, so the ordering in the definition of InterLinks matters.","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"However, DocumenterInterLinks implements a short-circuit mechanism to avoid having to specify the project when linking to code objects in most cases: If name starts with the name of a project followed by a period, then that project is searched first.","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"For example, in order to link to Documenter.makedocs, we can use","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"[`Documenter.makedocs`](@extref)","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"to immediately search the inventory links[\"Documenter\"], making the reference lookup as efficient as for the more verbose","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"[`Documenter.makedocs`](@extref Documenter)","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"Further @extref calls that will use the short-circuit mechanism for efficient lookup are","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"[`makedocs`](@extref Documenter.makedocs)\n[`makedocs`](@extref `Documenter.makedocs`)\n[`makedocs`](@extref :function:`Documenter.makedocs`)\n[`makedocs`](@extref :jl:function:`Documenter.makedocs`)","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"where the latter two are unnecessarily verbose, as Documenter.makedocs is already uniquely specified without the role or domain.","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"The short-circuit mechanism only works if the project name used in the instantiation of InterLinks matches the package name as it occurs in the fully specified name of any code object. That is, name the project \"Documenter\", not, e.g., \"Documenter121\" for version 1.2.1 of Documenter.","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"When this is not possible, e.g., for the Julia project which contains many different modules without a common prefix (Base, Core, LinearAlgebra, …), it is best to declare that project as the first element in InterLinks. That way,","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"[`Base.sort!`](@extref)","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"looks in the Julia project first, avoiding the need for","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"[`Base.sort!`](@extref Julia)","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"(although you may still prefer the latter as a matter of clarity).","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"warning: Warning\nIf possible, use the name of a package as it occurs in the fully specified name of any code objects when declaring the project in InterLinks.","category":"page"},{"location":"syntax/#Recommended-Syntax","page":"Syntax","title":"Recommended Syntax","text":"","category":"section"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"With the Performance Tips in mind, not all of the 10 possible Syntax forms are recommended in practice. For maximum clarity and performance, use the following guidelines:","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"When referencing section headers in another project, e.g., the Basic Markdown section in Documenter's documentation, look up the appropriate sluggified name:\nusing DocumenterInterLinks # hide\nlinks = InterLinks(\"Documenter\" => (\"https://documenter.juliadocs.org/stable/\", joinpath(@__DIR__, \"inventories\", \"Documenter.toml\")),\"Julia\" => (\"https://docs.julialang.org/en/v1/\", joinpath(@__DIR__, \"inventories\", \"Julia.toml\")),) # hide\nlinks[\"Documenter\"](\"Basic Markdown\")\nand use form (8):\n[Basic Markdown](@extref Documenter Basic-Markdown)\nWhen directly referencing a code object, e.g., Documenter.makedocs, use form (2):\n[`Documenter.makedocs`](@extref)\nMake sure that Documenter is a project name in links (see Performance Tips).\nThis gets slightly more complicated when the code object is a \"method\" (where the docstring is for specific types of arguments), e.g., Base.Filesystem.cd. You will generally have to look up the full name\nlinks[\"Julia\"](\"Base.Filesystem.cd\")\nand then use form (3),\n[`Base.Filesystem.cd`](@extref `Base.Filesystem.cd-Tuple{AbstractString}`)\nto link to a specific method. The use of backticks around the full method name is optional, but recommended especially when there are spaces in the type description. Note that if there is only a single method for a function, InterLinks by default (due to alias_methods_as_function) will add an alias that links the function name to that method docstring, allowing to use the shorter function name as a convenient target for the reference.\nIf the module name of the object cannot match the project name (e.g., for the Julia documentation, which contains docstrings for Base, Core, LinearAlgebra, etc.), use form (5),\n[`Base.sort!`](@extref Julia)\nWhen referencing a page, e.g., the Home page of the Documenter documentation, use form (9):\n[Home page of the Documenter documentation](@extref Documenter :doc:`index`)\nThe doc role is not strictly necessary, but it clearly distinguishes references to documents from references to headings (especially when both may exist with the same name).","category":"page"},{"location":"syntax/","page":"Syntax","title":"Syntax","text":"Thus, the most commonly used forms of syntax for @extref links should be (2), (3), and (8), highlighted with 🏅 in Syntax, with (5), and (9) being useful in some situations (🥈).","category":"page"},{"location":"api/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"api/internals/","page":"Internals","title":"Internals","text":"Modules = [DocumenterInterLinks]","category":"page"},{"location":"api/internals/#DocumenterInterLinks.ExtCrossReferences","page":"Internals","title":"DocumenterInterLinks.ExtCrossReferences","text":"Pipeline step to expand all @extref cross-references.\n\nThis runs before Documenter.Builder.CrossReferences.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/#DocumenterInterLinks.ExternalFallbacks","page":"Internals","title":"DocumenterInterLinks.ExternalFallbacks","text":"Plugin for letting @ref links fall back to @extref links.\n\nwarning: Warning\nThis plugin is available only with Documenter >= v1.3.0 and should be considered as experimental.\n\nfallbacks = ExternalFallbacks(pairs...)\n\ndefines a mapping of @ref-slugs to @external links. If an @ref cannot be resolved locally, the InterLinks plugin will be used to resolve it with the @extref link target defined in the mapping.\n\nThe @ref-slug can be found in the message printed by Documenter when it cannot resolve an @ref link, e.g.,\n\nError: Cannot resolve @ref for 'makedocs' …\nError: Cannot resolve @ref for 'Other-Output-Formats'\n\nfrom some unresolvable links [`makedocs`](@ref) and [Other Output Formats](@ref).\n\nThe \"slug\" is the string inside the quotes. It should be mapped to a complete @extref link, e.g.,\n\nfallbacks = ExternalFallbacks(\n    \"makedocs\" => \"@extref Documenter.makedocs\",\n    \"Other-Output-Formats\" =>  \"@extref Documenter `Other-Output-Formats`\",\n)\n\nThis will then resolve the link [`makedocs`](@ref) as if it had been written as [`makedocs`](@extref Documenter.makedocs), and [Other Output Format](@ref) as if it had been written as [Other Output Format](@extref Documenter `Other-Output-Formats`) and link to makedocs and Other Output Formats, respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/#DocumenterInterLinks.InterLinks","page":"Internals","title":"DocumenterInterLinks.InterLinks","text":"Plugin for enabling external links in Documenter.jl.\n\nlinks = InterLinks(\n    \"project1\" => \"https://project1.url/\",\n    \"project2\" => \"https://project2.url/inventory.file\",\n    \"project3\" => (\n        \"https://project3.url/\",\n        joinpath(@__DIR__, \"src\", \"interlinks\", \"inventory.file\")\n    );\n    default_inventory_file=\"objects.inv\",\n    alias_methods_as_function=true,\n)\n\ninstantiates a plugin object that must be passed as an element of the plugins keyword argument to Documenter.makedocs. This then enables @extref links in the project's documentation to be resolved, see the Documentation for details.\n\nArguments\n\nThe InterLinks plugin receives mappings of project names to the project root URL and inventory locations. Each project names must be an alphanumerical ASCII string. For Julia projects, it should be the name of the package without the .jl suffix, e.g., \"Documenter\" for Documenter.jl. For Python projects, it should be the name of project's main module.\n\nThe root url / inventory location (the value of the mapping), can be given in any of the following forms:\n\nA single string with a URL of the inventory file, e.g.\n\"sphinx\" => \"https://www.sphinx-doc.org/en/master/objects.inv\"`\nThe root URL relative which all URIs inside the inventory are taken to be relative is everything up to the final slash in the inventory URL, \"https://www.sphinx-doc.org/en/master/\" in this case.\nA single string with a project root URL, for example,\n\"sphinx\" => \"https://www.sphinx-doc.org/en/master/\",`\nwhich must end with slash. This looks for the inventory file with the name corresponding to default_inventory_file directly underneath the given root URL.\nA tuple of strings, where the first element is the project root URL and all subsequent elements are locations (URLs or local file paths) to an inventory file, e.g.,\n\"Julia\" => (\n    \"https://docs.julialang.org/en/v1/\",\n    joinpath(@__DIR__, \"src\", \"interlinks\", \"Julia.toml\")\n),\n\"Documenter\" => (\n    \"https://documenter.juliadocs.org/stable/\",\n    \"https://documenter.juliadocs.org/stable/inventory.toml.gz\",\n    joinpath(@__DIR__, \"src\", \"interlinks\", \"Documenter.toml\")\n)\nThe first reachable inventory file will be used. This enables, e.g., to define a local inventory file as a fallback in case the online inventory file location is unreachable, as in the last example.\nA DocInventories.Inventory instance.\n\nKeyword arguments\n\ndefault_inventory_file: The file name for the inventory file to use if the \"inventory location\" is given as the root URL. Since both Sphinx and Documenter automatically write objects.inv, there is little conceivable reason to set this to something other than the default objects.inv.\nalias_methods_as_function: If true (default), for any inventory loaded from a file or URL, automatically add a :jl:function: alias for any :jl:method if that alias is unambiguous. This accounts for Documenter preferentially generating method-docstrings from @autodoc blocks, even if that method is the only method for the underlying function. For example, the Documenter.Selectors.dispatch function only has a method-docstring that would have to be referenced as the excessively long\n[`Documenter.Selectors.dispatch`](@extref `Documenter.Selectors.dispatch-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T<:Documenter.Selectors.AbstractSelector`)\nWith the alias, this can be shortened to [`Documenter.Selectors.dispatch`](@extref). No alias will be created if there are docstrings for multiple methods of the same function, or if there is an existing function docstring.\n\nProperties\n\nnames: A list of project names\ninventories: A dictionary of project names to DocInventories.Inventory instances\nrx: a Regex that matches any valid @extref expression that can be resolved.\n\nThe InterLinks object also acts as a (read-only) ordered dictionary so that, e.g., links[\"project1\"] returns the DocInventories.Inventory for that project.\n\nSearch\n\nFree-form search in a particular inventory is possible with, e.g.,\n\nlinks[\"Julia\"](search)\n\nSee the discussion on search in the DocInventories.Inventory documentation. Such a search returns a list of matching DocInventories.InventoryItem instances.\n\nIn addition,\n\nlinks(search)\n\nallows to search across all inventories. This returns a list of @extref strings that could be used to reference the matching items.\n\nMethods\n\nfind_in_interlinks(links, extref) – find the URL for an extref\n\nSee also\n\nThe InterLinks mapping is deliberately reminiscent of the intersphinx_mapping setting in Sphinx.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/#DocumenterInterLinks.find_in_interlinks-Tuple{InterLinks, AbstractString}","page":"Internals","title":"DocumenterInterLinks.find_in_interlinks","text":"Find an @extref link in any of the InterLinks inventories.\n\nurl = find_in_interlinks(links, extref)\n\nfinds extref in links and returns the full URL that resolves the link.\n\nArguments\n\nlinks: the InterLinks instance to resolve the reference in\nextref: a string of the form  \"@extref [project] [[:domain][:role]:]name\"\n\n\n\n\n\n","category":"method"},{"location":"howtos/#How-Tos","page":"How-Tos","title":"How-Tos","text":"","category":"section"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"Pages=[\"howtos.md\"]\nDepth=3:3","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"","category":"page"},{"location":"howtos/#howto-inventory-location","page":"How-Tos","title":"How do I find a project's inventory file?","text":"","category":"section"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"The documentation generator should generate an inventory file in the root of its output folder. These then get deployed with the rest of the documentation. For most projects, this \"root\" ends up in a subfolder named after the version or branch.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"For example, you will find objects.inv inventory files under the following URLs:","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"https://www.sphinx-doc.org/en/master/objects.inv\nhttps://matplotlib.org/3.7.3/objects.inv\nhttps://docs.python.org/3/objects.inv\nhttps://juliadocs.org/DocInventories.jl/stable/objects.inv\nhttps://juliadocs.org/DocInventories.jl/v0.2/objects.inv\nhttps://documenter.juliadocs.org/stable/objects.inv","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"The Julia language currently does not provide an inventory file, but if it did, it would be immediately underneath","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"https://docs.julialang.org/en/v1/","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"If it is not obvious where an inventory file is located, simply try to load it in the REPL until you find a working URL:","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"using DocInventories\nInventory(\"https://www.sphinx-doc.org/en/objects.inv\")\nInventory(\"https://www.sphinx-doc.org/en/master/objects.inv\")","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"If you cannot find any inventory file, see What if I want to link to a project that does not provide an inventory file?","category":"page"},{"location":"howtos/#howto-find-extref","page":"How-Tos","title":"How do I figure out the correct name for the @extref link?","text":"","category":"section"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"Use the search capabilities of InterLinks or DocInventories.Inventory.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"If you have set up an InterLinks object named links in your docs/make.jl as described before, you are presumably able to build your documentation locally by starting a Julia REPL in the appropriate environment (e.g., julia --project=docs) and then running include(\"docs/make.jl\").","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"This also puts the links object into your REPL, allowing you to search it interactively.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"# include(\"docs/make.jl\")\nusing DocumenterInterLinks # hide\nlinks = InterLinks(\"sphinx\" => \"https://www.sphinx-doc.org/en/master/objects.inv\", \"matplotlib\" => \"https://matplotlib.org/3.7.3/\", \"Documenter\" => (\"https://documenter.juliadocs.org/stable/\", joinpath(@__DIR__, \"inventories\", \"Documenter.toml\")), \"Julia\" => (\"https://docs.julialang.org/en/v1/\", joinpath(@__DIR__, \"inventories\", \"Julia.toml\"))); # hide\nlinks","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"For example, trying to find the appropriate @extref link to to the LaTeX Syntax section in the Documenter manual, you might search for","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"links[\"Documenter\"](\"latex\")","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"and determine that an appropriate @extref would be","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"[LaTeX Syntax](@extref Documenter :label:`latex_syntax`)","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"This search is quite flexible. Using regular expression, you could do something crazy like search the Julia documentation for docstrings of any method that involves two or more strings:","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"links[\"Julia\"](r\":method:`.*-.*AbstractString.*AbstractString.*`\")","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"You can also search across all projects, using a lookup in the InterLinks object directly, e.g.,","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"links(\"`index`\")","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"These matching @extref links should be modified according to the Recommended Syntax.","category":"page"},{"location":"howtos/#howto-manual-inventory","page":"How-Tos","title":"What if I want to link to a project that does not provide an inventory file?","text":"","category":"section"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"Inventory files really should be created automatically using a documentation generator. Try to get the project to use one that produces inventory files or help them set up their documentation system so that it does.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"For a Documenter-based project that does not have an inventory file (presumably because it is using Documenter < v1.3.0), you can use the DocumenterInventoryWritingBackport package to create one locally. As an example, let's create an inventory file for Documenter v1.2 itself:","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"using Markdown\nSCRIPT = raw\"\"\"\n# Obtain a copy of the Documenter 1.2.0 source\ngit clone https://github.com/JuliaDocs/Documenter.jl.git\ncd Documenter.jl\ngit checkout -b inventory-writing v1.2.0\n\n# Instantiate the environment for building the documentation\njulia --project=docs -e '\n    using Pkg\n    Pkg.add(url=\"https://github.com/JuliaDocs/DocInventories.jl\")\n    Pkg.add(url=\"https://github.com/JuliaDocs/DocumenterInventoryWritingBackport.jl\")\n    Pkg.develop(path=\".\")\n    Pkg.instantiate()'\n\n# Build the documentation and convert the resulting inventory to TOML\njulia --project=docs -e '\n    using DocInventories\n    using DocumenterInventoryWritingBackport\n    include(\"docs/make.jl\")\n    DocInventories.convert(\"docs/build/objects.inv\", \"Documenter.toml\")'\n\"\"\"\n\nif Sys.isunix() && (get(ENV, \"GITHUB_REF_NAME\", \"\") == \"master\")\n    tmp = mktempdir(; cleanup=false)\n    println(\"---------------------------------------------------\")\n    println(\"Eval howto-manual-inventory example in tempdir=$tmp\")\n    cd(tmp) do\n        script = \"generate_inventory.sh\"\n        write(script, SCRIPT)\n        run(`/bin/bash $script`)\n        @assert isfile(joinpath(\"Documenter.jl\", \"Documenter.toml\"))\n    end\n    println(\"---------------------------------------------------\")\nend\n\nMarkdown.parse(\"\"\"\n```bash\n$SCRIPT\n```\n\"\"\")","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"Essentially, what we've done here is to open a Julia REPL like we normally would when building the package documentation locally. Before executing the docs/make.jl script, we've loaded the DocInventories and DocumenterInventoryWritingBackport packages. The latter one ensures that when Documenter runs, it will automatically create a compressed objects.inv inventory file in the docs/build folder. In the last step, we've converted that to the TOML Format.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"The above routine is how the local inventory files used in this documentation were generated. Using the TOML format is recommended for any inventory that will be committed to Git, as it is both human-readable and easier for git to track.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"warning: Warning\nMake sure that prettyurls=true in Documenter.makedocs, or, more specifically, that the prettyurls option is not set conditionally with something like prettyurls = get(ENV, \"CI\", nothing) == \"true\". This would cause a mismatch between the locally generated inventory and the deployed documentation.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"Some local inventory files are also available in the project wiki. You may contribute your own generated inventories there.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"There may be projects that legitimately do not provide inventories. For example, some simple Julia projects write out their entire documentation in their README on Github. In that case, you should either use standard links or manually create an inventory file. The easiest way to do this is to write out an inventory in TOML Format by hand.","category":"page"},{"location":"howtos/#howto-external-links","page":"How-Tos","title":"Can I use this plugin for general external links?","text":"","category":"section"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"Documenter's markdown flavor lacks the ability for reference links. If you link to the same very long URLs repeatedly, this becomes cumbersome.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"In principle, you could manually write out an inventory file that defines link labels and their associated URLs, along the lines of the discussion in Documenter's PR #1351. Whether you should abuse DocumenterInterLinks in this way might be a matter of debate.","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"A situation where I do think this makes sense is if you repeatedly link to some website with very structured content, e.g. Wikipedia or the Julia Discourse Forum. As shown in the DocInventories documentation, you could write a Wikipedia inventory file just for the articles you want to link to, and then have a link such as","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"[Julia](@extref Wikipedia)","category":"page"},{"location":"howtos/","page":"How-Tos","title":"How-Tos","text":"in your documentation to link to Julia (programming language).","category":"page"},{"location":"sphinx-to-documenter-links/README/#Demo-for-Linking-from-Sphinx-to-Documenter","page":"Demo for Linking from Sphinx to Documenter","title":"Demo for Linking from Sphinx to Documenter","text":"","category":"section"},{"location":"sphinx-to-documenter-links/README/","page":"Demo for Linking from Sphinx to Documenter","title":"Demo for Linking from Sphinx to Documenter","text":"This Python project demos a Sphinx documentation that links to an external Julia project documentation via Intersphinx.","category":"page"},{"location":"sphinx-to-documenter-links/README/","page":"Demo for Linking from Sphinx to Documenter","title":"Demo for Linking from Sphinx to Documenter","text":"See the Compatibility with Sphinx section in the DocumenterInterLinks documentation.","category":"page"},{"location":"sphinx-to-documenter-links/README/#Building-the-Documentation","page":"Demo for Linking from Sphinx to Documenter","title":"Building the Documentation","text":"","category":"section"},{"location":"sphinx-to-documenter-links/README/","page":"Demo for Linking from Sphinx to Documenter","title":"Demo for Linking from Sphinx to Documenter","text":"This requires a recent version of Python and Hatch to be installed ","category":"page"},{"location":"sphinx-to-documenter-links/README/","page":"Demo for Linking from Sphinx to Documenter","title":"Demo for Linking from Sphinx to Documenter","text":"If you have the make installed, you can run","category":"page"},{"location":"sphinx-to-documenter-links/README/","page":"Demo for Linking from Sphinx to Documenter","title":"Demo for Linking from Sphinx to Documenter","text":"make docs","category":"page"},{"location":"sphinx-to-documenter-links/README/","page":"Demo for Linking from Sphinx to Documenter","title":"Demo for Linking from Sphinx to Documenter","text":"Or alternatively,","category":"page"},{"location":"sphinx-to-documenter-links/README/","page":"Demo for Linking from Sphinx to Documenter","title":"Demo for Linking from Sphinx to Documenter","text":"hatch run docs:build","category":"page"},{"location":"write_inventory/#Inventory-Generation","page":"Inventory Generation","title":"Inventory Generation","text":"","category":"section"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"The inventory files that get loaded into InterLinks should be automatically created by a project's documentation generator.","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"The Sphinx documentation generator used by most Python packages automatically creates an objects.inv inventory file in the root of every HTML build.\nFor Julia projects that build their documentation with Documenter ≥ v1.3, an objects.inv inventory file in the same format is automatically created in the docs/build/ folder.\nDocumenterInventoryWritingBackport.jl backports the automatic inventory writing to older versions of Documenter (≥ v0.25). This package simply needs to be loaded in a project's docs/make.jl file.\nAny package loading DocumenterInterLinks in docs/make.jl also gets the DocumenterInventoryWritingBackport automatically.","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"The inventory file should be deployed together with the rest of the documentation, so that it is accessible to other projects. When a project does not use a documentation generator that writes an inventory file, it may be possible to maintain an inventory by hand. See also the Wiki for a collection of inventory files for Julia and other projects.","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"For a Documenter-based project, the automatic inventory contains:","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"An entry for every docstring included in the documentation. These use the ad-hoc jl domain and a role that depends on the object.\nAn entry for every section heading. To ensure compatibility with Sphinx, these entries use the std domain, the label role, a slugified version of the heading (or the explicit header @id) as a name, and the full heading (stripped of formatting, but including spaces) as the dispname.\nAn entry for every page in the documentation. These use the std domain and the doc role. The name is the path (with Unix-style forward-slash path separators) of the .md file from which the page was generated, without the .md extension. This should correspond to the relative URI of the resulting page, excluding a final slash or an .html extension.","category":"page"},{"location":"write_inventory/#The-Julia-Domain","page":"Inventory Generation","title":"The Julia Domain","text":"","category":"section"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"info: Info\nYou  probably will not need to worry about the information in this section.","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"The inventory for a Documenter-based documentation includes entries for docstrings using an ad-hoc jl domain. The role for each entry matches how Documenter identifies the underlying object with Documenter.doccat. You will find this identification as part of how the docstring shows in the documentation; for example, note the \"— Type\" in the header of DocumenterInterLinks.InterLinks. The role that will be written to the inventory is simply the lowercase string of this identification. Currently, Documenter uses the following:","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"\"Macro\" (role macro): for macros. For example, \":jl:macro:`Base.@inbounds`\" for Base.@inbounds.\n\"Keyword\" (role keyword): for Julia keywords (used in the documentation of the Julia language itself, only). For example, \":jl:keyword:`if`\" for the if keyword.\n\"Function\" (role function): for functions. For example, \":jl:function:`Statistics.mean`\" for Statistics.mean.\n\"Method\" (role method): for methods of functions. This is used when there is a docstring for a specific tuple of argument types. For example, \":jl:method:`Base.:*-Tuple{AbstractMatrix, AbstractMatrix}`\" for the * operator of two matrices.\n\"Type\" (role type): For types, both structs and abstract types. For example, \":jl:type:`Base.AbstractMatrix`\" for AbstractMatrix.\n\"Module\" (role module): For modules. For example, \":jl:module:`LinearAlgebra.BLAS`\" for LinearAlgebra.BLAS.\n\"Constant\" (role constant): For documented data / constants inside a module. For example, \":jl:constant:`Base.VERSION`\" for Julia's VERSION constant.","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"As discussed in Syntax, the domain and roles are for disambiguation only. In practice, the above example references might be written as","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"* [`Base.@inbounds`](@extref)\n* [the `if` keyword](@extref Julia `if`)\n* [`Statistics.mean`](@extref)\n* [`*` operator of two matrices](@extref `Base.:*-Tuple{AbstractMatrix, AbstractMatrix}`)\n* [`LinearAlgebra.BLAS`](@extref)\n* [Julia's `VERSION` constant](@extref `Base.VERSION`)","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"These render as:","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"Base.@inbounds\nthe if keyword\nStatistics.mean\n* operator of two matrices\nLinearAlgebra.BLAS\nJulia's VERSION constant","category":"page"},{"location":"write_inventory/","page":"Inventory Generation","title":"Inventory Generation","text":"Leaving out the project name Julia in all but the second item is recommended only if Julia is the first project in the InterLinks object.","category":"page"},{"location":"#DocumenterInterLinks.jl","page":"Home","title":"DocumenterInterLinks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\n\nVERSION = Pkg.dependencies()[Base.UUID(\"d12716ef-a0f6-4df4-a9f1-a5a34e75c656\")].version\n\ngithub_badge = \"[![Github](https://img.shields.io/badge/JuliaDocs-DocumenterInterLinks.jl-blue.svg?logo=github)](https://github.com/JuliaDocs/DocumenterInterLinks.jl)\"\n\nversion_badge = \"![v$VERSION](https://img.shields.io/badge/version-v$(replace(\"$VERSION\", \"-\" => \"--\"))-green.svg)\"\n\nif get(ENV, \"DOCUMENTER_BUILD_PDF\", \"\") == \"\"\n    Markdown.parse(\"$github_badge $version_badge\")\nelse\n    Markdown.parse(\"\"\"\n    -----\n\n    On Github: [JuliaDocs/DocumenterInterLinks.jl](https://github.com/JuliaDocs/DocumenterInterLinks.jl)\n\n    Version: $VERSION\n\n    -----\n\n    \"\"\")\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocumenterInterLinks.jl is a plugin for Documenter.jl to link to external projects. It is interoperable with Intersphinx for Python projects.","category":"page"},{"location":"#Installation-Instructions","page":"Home","title":"Installation Instructions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As usual, the package can be installed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add DocumenterInterLinks","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the Julia REPL, or by adding","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocumenterInterLinks = \"d12716ef-a0f6-4df4-a9f1-a5a34e75c656\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"to the relevant Project.toml file (e.g., docs/Project.toml).","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In your docs/make.jl file, load the DocumenterInterLinks package (using DocumenterInterLinks).\nDeclare external projects by instantiating an InterLinks object and passing it as part of plugins to Documenter.makedocs.\nReference items from any external project with an @extref link in your documentation.","category":"page"},{"location":"#Declaring-External-Projects","page":"Home","title":"Declaring External Projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In docs/make.jl, instantiate an InterLinks object to define external projects you want to link to. For example,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DocumenterInterLinks\n\nlinks = InterLinks(\n    \"sphinx\" => \"https://www.sphinx-doc.org/en/master/\",\n    \"matplotlib\" => \"https://matplotlib.org/3.7.3/objects.inv\",\n    \"Julia\" => (\n        \"https://docs.julialang.org/en/v1/\",\n        joinpath(@__DIR__, \"inventories\", \"Julia.toml\")\n    ),\n    \"Documenter\" => (\n        \"https://documenter.juliadocs.org/stable/\",\n        \"https://documenter.juliadocs.org/stable/objects.inv\",\n        joinpath(@__DIR__, \"inventories\", \"Documenter.toml\")\n    ),\n);\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"defines the external projects \"sphinx\", \"matplotlib\", and \"Julia\". For each project, it specifies the root URL of that project's online documentation and the location of an inventory file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above examples illustrates three possibilities for specifying the root url and inventory location","category":"page"},{"location":"","page":"Home","title":"Home","text":"Map that project name to project root URL. This will look for an inventory file objects.inv directly underneath the given URL. This is the recommended from in most cases.\nMap the project name to the URL of an inventory file. The project root URL is the given URL without the filename.\nMap the project name to a tuple containing the root URL first, and then one or more possible locations for an inventory file. These may be local file paths, which allows using a self-maintained inventory file for a project that does not provide one.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the doc-string of InterLinks for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThe instantiated links object must be passed to Documenter.makedocs as an element to the plugins keyword argument.","category":"page"},{"location":"#Inventories","page":"Home","title":"Inventories","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The inventory files referenced when instantiating InterLinks are assumed to have been created by a documentation generator, see Inventory Generation. The DocInventories package is used as a backend to parse these files into DocInventories.Inventory objects. These are accessible by using links as a dict:","category":"page"},{"location":"","page":"Home","title":"Home","text":"links[\"sphinx\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"As we can see, inventories contain a mapping of names to linkable locations relative to the root URL of a project's online documentation, see DocInventories.InventoryItem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The DocInventories package provides tools for interactively searching inventories for items to reference. See Exploring Inventories and How do I figure out the correct name for the @extref link?.","category":"page"},{"location":"#Using-External-References","page":"Home","title":"Using External References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The DocumenterInterLinks plugin adds support for @extref link targets to Documenter. At the most fundamental level, they work just like Documenter's standard @ref link targets. Replacing @ref with @extref switches from a local reference to an external one:","category":"page"},{"location":"","page":"Home","title":"Home","text":"* [`Documenter.makedocs`](@extref)\n* [Documenter's `makedocs` function](@extref Documenter.makedocs)\n* See the section about Documenter's [Writers](@extref).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above markdown code renders as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documenter.makedocs\nDocumenter's makedocs function\nSee the section about Documenter's Writers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To disambiguate (and speed up) the references, the name of the inventory (as defined when instantiating InterLinks) can be included in the @extref. In particular, the last example should have been written as","category":"page"},{"location":"","page":"Home","title":"Home","text":"* See the section about Documenter's [Writers](@extref Documenter).","category":"page"},{"location":"","page":"Home","title":"Home","text":"to clarify that we are linking to the section name \"Writers\" found in links[\"Documenter\"]. When the link text and link target differ, the inventory name should be given between @extref and the target name, e.g., [`Regex`](@extref Julia Base.Regex), which turns into \"Regex\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since DocumenterInterLinks is fully compatible with Sphinx inventories, it also provides an extended @extref syntax that builds on the Sphinx concept of \"domains\" and \"roles\". You will see these when inspecting an InventoryItem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DocInventories\n\nDocInventories.show_full(links[\"Documenter\"][\"Documenter.makedocs\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can include the domain and role in an @extref link as","category":"page"},{"location":"","page":"Home","title":"Home","text":"* [`makedocs`](@extref :function:`Documenter.makedocs`)\n* [`makedocs`](@extref :jl:function:`Documenter.makedocs`)","category":"page"},{"location":"","page":"Home","title":"Home","text":"using a syntax that is reminiscent of the Sphinx cross-referencing syntax. The use of domains and roles in DocumenterInterLinks (unlike in Sphinx) is for disambiguation only, in case there are multiple items with the same name. In general, follow the Recommended Syntax guidelines.","category":"page"},{"location":"fallback/#Fallback-Resolution","page":"Fallback Resolution","title":"Fallback Resolution","text":"","category":"section"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"warning: Warning\nThe ExternalFallbacks plugin described here is available only with Documenter >= v1.3.0 and should be considered experimental.","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"In some situations, you may need to include a docstring from an external package in your documentation – for example, you you are extending a function from that package, you may want to show the function docstring. If that docstrings contains an @ref link, you have a problem: that link is resolvable in the external documentation, but not in your documentation.","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"If the @ref link is to another code object, you could include that docstring in your documentation as well, and so forth, until all references can be resolved. Unfortunately, you might end up having to include a significant portion of the external package's documentation, which is less than ideal.","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"The situation is even worse if the @ref link is to a section header. For example, the docstring of DocInventories.MIME_TYPES includes a reference to the section on inventory file formats in the DocInventories documentation. In that case, there is no way to make the reference resolve in your documentation (short of adding an \"Inventory File Formats\" section to your own documentation).","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"To remedy this, the DocumenterInterLinks package provides a special plugin, ExternalFallbacks, that can rewrite specific @ref links to @extref links. It is instantiated by providing a mapping between \"slugs\" and @extref link specifications. For example,","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"fallbacks = ExternalFallbacks(\n    \"Inventory-File-Formats\" => \"@extref DocInventories `Inventory-File-Formats`\",\n)","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"warning: Warning\nLike any plugin, fallbacks must be passed to Documenter.makedocs as an element of plugins.","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"The \"slug\" on the left-hand-side of the mapping can be obtained from message that Documenter prints when it fails to resolve the @ref link. Generally, for [Section Title](@ref) or [text](@ref \"Section Title), the slug is a \"sluggified\" version of the title (determined internally by Documenter, mostly just replacing spaces with dashes); and for [`code`](@ref) or [text](@ref code), it is \"code\". The right-hand-side of the mapping is a full @extref link. The plugin simply replaces the link target of original @ref link with the given @extref.","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"If there are any unresolvable @ref links, and there is no explicit @extref-mapping, ExternalFallbacks will search in all available inventories to resolve the link in an \"automatic\" mode. In this case, you will see messages like","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"[ Info: ExternalFallbacks automatic resolution of \"Inventory-File-Formats\" => \"@extref DocInventories :std:label:`Inventory-File-Formats`\"","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"in the output of Documenter.makedocs. If this is correct, you should copy \"Inventory-File-Formats\" => \"@extref DocInventories :std:label:`Inventory-File-Formats`\" explicitly into the instantiation of the ExternalFallbacks plugin. The \"automatic resolution\" is both slow and has the potential for misidentifying the @extref link.","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"warning: Warning\nDo not use @ref links in your documentation for known @extref targets! The ExternalFallbacks plugin is intended as a \"last resort\", to be used deliberately, not to automatically resolve all @ref links via InterLinks.","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"With an @extref mapping for \"Inventory-File-Formats\" in place, it is now possible to include the docstring for DocInventories.MIME_TYPES:","category":"page"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"DocInventories.MIME_TYPES","category":"page"},{"location":"fallback/#DocInventories.MIME_TYPES","page":"Fallback Resolution","title":"DocInventories.MIME_TYPES","text":"Default map of file extensions to MIME types.\n\nMIME_TYPES = Dict(\n    \".txt\" => MIME(\"text/x-intersphinx\"),\n    \".inv\" => MIME(\"application/x-intersphinx\"),\n    \".toml\" => MIME(\"application/toml\"),\n    \".txt.gz\" => MIME(\"text/x-intersphinx+gzip\"),\n    \".toml.gz\" => MIME(\"application/toml+gzip\"),\n)\n\nSee Inventory File Formats for details.\n\n\n\n\n\n","category":"constant"},{"location":"fallback/","page":"Fallback Resolution","title":"Fallback Resolution","text":"Note that the link in the last line of the docstring is an external link.","category":"page"},{"location":"sphinx/#Compatibility-with-Sphinx","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"","category":"section"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"info: Info\nThis section goes into some fairly technical details. You do not need to read it unless you use both Documenter and Sphinx and plan to link both ways between Julia and Python projects.","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"DocumenterInterLinks is interoperable with Sphinx and Intersphinx: The InterLinks object can refer to the objects.inv file that Sphinx automatically writes out for every project. This makes it possible to easily link to virtually every Python project (as well as any other C/C++/Fortran project that uses Sphinx for its documentation).","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"The possible specification :domain:role:`name` in an @extref link mimics the cross-referencing syntax in Sphinx. However, Sphinx reStructuredText is much more explicit than Documenter's markdown syntax. In particular, the domain and role are required for every reference (although projects can set up a default domain, usually py, which can then be omitted). This is not the case in the @extref syntax defined by DocumenterInterLinks, where domain and role are for disambiguation only and can (and usually should) be omitted.","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"Moreover, domains and roles must be formally  defined in Sphinx. In fact, Sphinx makes a distinction between \"type\" and \"role\". Strictly speaking, the objects.inv file records an \"object type\", like function or module, which DocInventories.InventoryItem reads in as role. A Sphinx domain then defines \"roles\" on top of that which are used for referencing object. The formal definition of the domain includes a mapping between an object type and one or more roles. Consider for example the code of the PythonDomain, which defines an object type function with associated roles func and obj. In contrast, DocumenterInterLinks has no formally defined domains and makes no distinction between object types and roles. Thus, the inventory item links[\"matplotlib\"][\":py:function:`matplotlib.get_backend`\"] would be referenced as :py:func:`matplotlib.get_backend` (using :func:, not :function:!) or :py:obj:`matplotlib.get_backend` in Sphinx, but as [`get_backend`](@extref :py:function:`matplotlib.get_backend`) in DocumenterInterLinks, or more simply without any domain or role as [`matplotlib.get_backend`](@extref).","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"Note that Sphinx has a \"fallback\" feature similar to the one implemented for Documenter ≥ v1.3.0 via ExternalFallbacks, see Fallback Resolution. In fact, that fallback is used extensively in Sphinx, preferring shorter references like :py:class:`zipfile.ZipFile` in lieu of the proper :external: role. This approach is not recommended in DocumenterInterLinks. Never use an @ref link when the link target is known to be an @extref! When this is not possible, use explicit mappings in the ExternalFallbacks plugin.","category":"page"},{"location":"sphinx/#Referencing-the-Julia-domain-in-Sphinx","page":"Compatibility with Sphinx","title":"Referencing the Julia domain in Sphinx","text":"","category":"section"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"The formal nature of Sphinx domains also has consequences for referencing Julia objects from within a Sphinx project. Linking from a project using Sphinx as a documentation generator to a Julia project using Documenter and the automatic inventory generation provided by DocumenterInterLinks will not work out of the box. This is because Sphinx does not know about the jl domain. In this sense, the jl domain is considered \"ad-hoc\".","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"There is a Sphinx-Julia package, but that package is currently not functional, and only partially supports the object types / roles used here in The Julia Domain.","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"Thus, any Sphinx project that wants to link to inventory items in the jl domain must first formally specify that domain. This could be done by adding the following code to the Sphinx conf.py file (or an extension):","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"using Markdown\njulia_domain_py = joinpath(\n    @__DIR__, \"..\", \"src\", \"sphinx-to-documenter-links\",\n    \"docs\", \"source\", \"_extensions\", \"julia_domain.py\"\n)\nMarkdown.parse(\"\"\"\n```python\n$(read(julia_domain_py, String))\n```\n\"\"\")","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"We have used Sphinx' Domain API here to define the object types matching our Julia Domain. For each object type, we define a role of the same name, as well as abbreviated roles in line with Sphinx' usual conventions, such as :func: as a shorthand for :function: and obj for any type.","category":"page"},{"location":"sphinx/","page":"Compatibility with Sphinx","title":"Compatibility with Sphinx","text":"See sphinx-to-documenter-links for a full example of a Python project with documentation linking to the documentation of Julia projects.","category":"page"}]
}
